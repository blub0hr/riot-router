{"version":3,"sources":["webpack:///router.min.js","webpack:///webpack/bootstrap e4100e79d53440384f82","webpack:///./router.js","webpack:///external \"riot\"","webpack:///./~/riot-route/dist/cjs.route.js","webpack:///./~/riot-observable/dist/observable.js","webpack:///./~/extend/index.js"],"names":["router","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","global","factory","apply","undefined","this","riot","riotroute","extend","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","TypeError","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","_classCallCheck","instance","Constructor","customRiotParser","path","raw","split","uri","query","params","forEach","v","push","_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","_s","_i","Symbol","iterator","next","done","length","err","Array","isArray","_get","get","object","property","receiver","Function","desc","getOwnPropertyDescriptor","parent","getPrototypeOf","getter","_createClass","defineProperties","target","props","descriptor","defineProperty","key","protoProps","staticProps","error","console","Router","observable","interceptors","processRoute","bind","handler","InitialRoute","current","Context","response","process","routes","route","interceptor","slice","arguments","filter","join","context","Request","rootContext","processRequest","processInterceptors","processResponse","isRedirect","processRedirect","request","redirectTo","trigger","addRedirect","navigateTo","args","splice","preInterceptors","postInterceptors","concat","stop","processor","shift","parser","start","exec","Response","redirectStack","indexOf","Error","Handler","matcher","matches","routeMatch","routeMiss","add","t","ChildRequest","Route","_Handler","options","_this","tag","api","name","updatable","pathParameterNames","getPath","replace","pattern","ignored","group","regex","RegExp","redirectRoutes","r","RedirectRoute","defaultRoutes","DefaultRoute","notFoundRoutes","NotFoundRoute","otherRoutes","_routes","hasOwnProperty","decodeURIComponent","parseInt","found","processRoutes","createRequest","_Route","substring","parentUri","_Handler2","_this3","_Handler3","_this4","from","to","_Handler4","_this5","trim","index","opts","calculateLevel","level","__router_level","__router_tag","normalizeTag","result","unmountTag","unmount","mountTag","_normalizeTag","_normalizeTag2","canUpdate","update","root","replaceChild","document","createElement","children","mount","instanceTag","instanceApi","config","isMounted","updateRoute","size","on","off","_","_interopDefault","ex","DEFAULT_PARSER","DEFAULT_SECOND_PARSER","f","re","match","debounce","fn","delay","clearTimeout","setTimeout","autoExec","debouncedEmit","emit","win","ADD_EVENT_LISTENER","POPSTATE","HASHCHANGE","doc","clickEvent","click","$","central","s","e","normalize","isString","str","getPathFromRoot","href","loc","RE_ORIGIN","getPathFromBase","base","force","isRoot","emitStackLevel","MAX_EMIT_STACK_LEVEL","emitStack","TRIGGER","first","which","metaKey","ctrlKey","shiftKey","defaultPrevented","el","nodeName","parentNode","HAS_ATTRIBUTE","go","title","preventDefault","shouldReplace","hist","replaceState","pushState","routeFound","secondParser","EVENT_LISTENER","REMOVE_EVENT_LISTENER","window","history","location","prot","ontouchstart","started","second","third","some","action","mainRouter","newSubRouter","arg","fn2","q","k","readyState","callbacks","event","cb","one","fns","arglen","hasOwn","toStr","toString","isPlainObject","obj","hasOwnConstructor","hasIsPrototypeOf","src","copy","copyIsArray","clone","deep"],"mappings":"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","file":"router.min.js","sourcesContent":["var router =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n\t  if (true) {\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, __webpack_require__(1), __webpack_require__(2), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if (typeof exports !== \"undefined\") {\n\t    factory(module, require('riot'), require('riot-route'), require('extend'));\n\t  } else {\n\t    var mod = {\n\t      exports: {}\n\t    };\n\t    factory(mod, global.riot, global.riotRoute, global.extend);\n\t    global.router = mod.exports;\n\t  }\n\t})(this, function (module, riot, riotroute, extend) {\n\t  'use strict';\n\t\n\t  var _slicedToArray = function () {\n\t    function sliceIterator(arr, i) {\n\t      var _arr = [];\n\t      var _n = true;\n\t      var _d = false;\n\t      var _e = undefined;\n\t\n\t      try {\n\t        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n\t          _arr.push(_s.value);\n\t\n\t          if (i && _arr.length === i) break;\n\t        }\n\t      } catch (err) {\n\t        _d = true;\n\t        _e = err;\n\t      } finally {\n\t        try {\n\t          if (!_n && _i[\"return\"]) _i[\"return\"]();\n\t        } finally {\n\t          if (_d) throw _e;\n\t        }\n\t      }\n\t\n\t      return _arr;\n\t    }\n\t\n\t    return function (arr, i) {\n\t      if (Array.isArray(arr)) {\n\t        return arr;\n\t      } else if (Symbol.iterator in Object(arr)) {\n\t        return sliceIterator(arr, i);\n\t      } else {\n\t        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n\t      }\n\t    };\n\t  }();\n\t\n\t  function _possibleConstructorReturn(self, call) {\n\t    if (!self) {\n\t      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n\t    }\n\t\n\t    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n\t  }\n\t\n\t  var _get = function get(object, property, receiver) {\n\t    if (object === null) object = Function.prototype;\n\t    var desc = Object.getOwnPropertyDescriptor(object, property);\n\t\n\t    if (desc === undefined) {\n\t      var parent = Object.getPrototypeOf(object);\n\t\n\t      if (parent === null) {\n\t        return undefined;\n\t      } else {\n\t        return get(parent, property, receiver);\n\t      }\n\t    } else if (\"value\" in desc) {\n\t      return desc.value;\n\t    } else {\n\t      var getter = desc.get;\n\t\n\t      if (getter === undefined) {\n\t        return undefined;\n\t      }\n\t\n\t      return getter.call(receiver);\n\t    }\n\t  };\n\t\n\t  function _inherits(subClass, superClass) {\n\t    if (typeof superClass !== \"function\" && superClass !== null) {\n\t      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n\t    }\n\t\n\t    subClass.prototype = Object.create(superClass && superClass.prototype, {\n\t      constructor: {\n\t        value: subClass,\n\t        enumerable: false,\n\t        writable: true,\n\t        configurable: true\n\t      }\n\t    });\n\t    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n\t  }\n\t\n\t  function _classCallCheck(instance, Constructor) {\n\t    if (!(instance instanceof Constructor)) {\n\t      throw new TypeError(\"Cannot call a class as a function\");\n\t    }\n\t  }\n\t\n\t  var _createClass = function () {\n\t    function defineProperties(target, props) {\n\t      for (var i = 0; i < props.length; i++) {\n\t        var descriptor = props[i];\n\t        descriptor.enumerable = descriptor.enumerable || false;\n\t        descriptor.configurable = true;\n\t        if (\"value\" in descriptor) descriptor.writable = true;\n\t        Object.defineProperty(target, descriptor.key, descriptor);\n\t      }\n\t    }\n\t\n\t    return function (Constructor, protoProps, staticProps) {\n\t      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t      if (staticProps) defineProperties(Constructor, staticProps);\n\t      return Constructor;\n\t    };\n\t  }();\n\t\n\t  var error = console && console.error || function () {};\n\t\n\t  function customRiotParser(path) {\n\t    var raw = path.split('?'),\n\t        uri = raw[0].split('/'),\n\t        query = raw[1],\n\t        params = {};\n\t    if (query) {\n\t      query.split('&').forEach(function (v) {\n\t        var c = v.split('=');\n\t        params[c[0]] = c[1];\n\t      });\n\t    }\n\t    uri.push(params);\n\t    return uri;\n\t  }\n\t\n\t  var Router = function () {\n\t    function Router() {\n\t      _classCallCheck(this, Router);\n\t\n\t      riot.observable(this);\n\t      this.interceptors = [this.processRoute.bind(this)];\n\t      this.handler = new InitialRoute();\n\t      this.current = new Context(\"\").response;\n\t      this.process = this.process.bind(this);\n\t    }\n\t\n\t    _createClass(Router, [{\n\t      key: 'route',\n\t      value: function route(handler) {\n\t        this.handler = handler;\n\t      }\n\t    }, {\n\t      key: 'routes',\n\t      value: function routes(_routes) {\n\t        this.route(new InitialRoute().routes(_routes));\n\t      }\n\t    }, {\n\t      key: 'use',\n\t      value: function use(interceptor) {\n\t        this.interceptors.push(interceptor);\n\t      }\n\t    }, {\n\t      key: 'process',\n\t      value: function process() {\n\t        var params = Array.prototype.slice.call(arguments);\n\t        var query = {};\n\t        var uri = params.filter(function (p) {\n\t          if (typeof p !== 'string') {\n\t            query = p;\n\t            return false;\n\t          }\n\t          return true;\n\t        }).join(\"/\");\n\t        if (uri[0] !== '/') uri = \"/\" + uri; // handle '#any' as '#/any'\n\t        var context = new Context(new Request(uri, query));\n\t        if (!this.rootContext) this.rootContext = context;\n\t        this.processRequest(context);\n\t        return context;\n\t      }\n\t    }, {\n\t      key: 'processRequest',\n\t      value: function processRequest(context) {\n\t        this.processInterceptors(context);\n\t        return this.processResponse(context);\n\t      }\n\t    }, {\n\t      key: 'processResponse',\n\t      value: function processResponse(context) {\n\t        if (this.isRedirect(context)) {\n\t          return this.processRedirect(context);\n\t        }\n\t        var request = context.request,\n\t            response = context.response;\n\t\n\t        if (!response.redirectTo) {\n\t          this.current = response;\n\t          this.rootContext = null;\n\t          this.trigger('route:updated', response);\n\t          return context;\n\t        }\n\t      }\n\t    }, {\n\t      key: 'isRedirect',\n\t      value: function isRedirect(context) {\n\t        return !!context.response.redirectTo;\n\t      }\n\t    }, {\n\t      key: 'processRedirect',\n\t      value: function processRedirect(context) {\n\t        var uri = context.response.redirectTo;\n\t        this.rootContext.addRedirect(uri);\n\t        this.navigateTo(uri);\n\t      }\n\t    }, {\n\t      key: 'navigateTo',\n\t      value: function navigateTo() {\n\t        var args = Array.prototype.slice.call(arguments);\n\t        if (typeof args[1] === 'boolean') {\n\t          args.splice(1, 0, '');\n\t        }\n\t        riotroute.apply(null, args);\n\t      }\n\t    }, {\n\t      key: 'processInterceptors',\n\t      value: function processInterceptors(context, preInterceptors, postInterceptors) {\n\t        var interceptors = (preInterceptors || []).concat(this.interceptors).concat(postInterceptors || []);\n\t        var next = function next() {\n\t          if (!context.stop) {\n\t            var processor = interceptors.shift();\n\t            var request = context.request,\n\t                response = context.response;\n\t\n\t            if (processor) {\n\t              return processor(request, response, next, context);\n\t            }\n\t          }\n\t          return context;\n\t        };\n\t        return next();\n\t      }\n\t    }, {\n\t      key: 'processRoute',\n\t      value: function processRoute(request, response, next, context) {\n\t        this.handler.process(request, response, context);\n\t        return next();\n\t      }\n\t    }, {\n\t      key: 'start',\n\t      value: function start() {\n\t        riotroute.parser(customRiotParser);\n\t        riotroute(this.process);\n\t        riotroute.start();\n\t        this.exec();\n\t      }\n\t    }, {\n\t      key: 'exec',\n\t      value: function exec() {\n\t        riotroute.exec(this.process);\n\t      }\n\t    }]);\n\t\n\t    return Router;\n\t  }();\n\t\n\t  var Context = function () {\n\t    function Context(request) {\n\t      _classCallCheck(this, Context);\n\t\n\t      this.request = typeof request === 'string' ? new Request(request) : request;\n\t      this.response = new Response(this.request);\n\t      this.redirectStack = [];\n\t    }\n\t\n\t    _createClass(Context, [{\n\t      key: 'addRedirect',\n\t      value: function addRedirect(uri) {\n\t        if (this.redirectStack.indexOf(uri) > -1) throw new Error(\"Cyclic redirection to \" + uri + \". Stack = \" + this.redirectStack);\n\t        this.redirectStack.push(uri);\n\t      }\n\t    }]);\n\t\n\t    return Context;\n\t  }();\n\t\n\t  var Handler = function () {\n\t    function Handler() {\n\t      _classCallCheck(this, Handler);\n\t    }\n\t\n\t    _createClass(Handler, [{\n\t      key: 'matches',\n\t      value: function matches(request) {\n\t        return false;\n\t      }\n\t    }, {\n\t      key: 'process',\n\t      value: function process(request, response) {\n\t        var matcher = this.matches(request);\n\t        if (!matcher) return this.routeMiss(request, response);\n\t        return this.routeMatch(request, response, matcher);\n\t      }\n\t    }, {\n\t      key: 'routeMatch',\n\t      value: function routeMatch(request, response, matcher) {\n\t        response.add(matcher);\n\t        return true;\n\t      }\n\t    }, {\n\t      key: 'routeMiss',\n\t      value: function routeMiss(request, response) {\n\t        return false;\n\t      }\n\t    }, {\n\t      key: 'processRoutes',\n\t      value: function processRoutes(request, response, routes) {\n\t        if (routes && routes.length) {\n\t          var t = routes.length;\n\t          for (var i = 0; i < t; i++) {\n\t            var route = routes[i];\n\t            if (route.process(request, response)) return true;\n\t          }\n\t          return false;\n\t        }\n\t      }\n\t    }, {\n\t      key: 'createRequest',\n\t      value: function createRequest(request, matcher) {\n\t        return new ChildRequest(request, matcher);\n\t      }\n\t    }]);\n\t\n\t    return Handler;\n\t  }();\n\t\n\t  var Route = function (_Handler) {\n\t    _inherits(Route, _Handler);\n\t\n\t    function Route(options) {\n\t      _classCallCheck(this, Route);\n\t\n\t      var _this = _possibleConstructorReturn(this, (Route.__proto__ || Object.getPrototypeOf(Route)).call(this, options));\n\t\n\t      options = options || {};\n\t      _this.tag = options.tag;\n\t      _this.api = options.api;\n\t      _this.path = options.path;\n\t      _this.name = options.name;\n\t      _this.updatable = options.updatable;\n\t      _this.pathParameterNames = [];\n\t      var path = _this.getPath().replace(/^\\//, \"\");\n\t      _this.pattern = \"^/?\" + path.replace(/:([^/]+)/g, function (ignored, group) {\n\t        this.pathParameterNames.push(group);\n\t        return \"([^/]+)\";\n\t      }.bind(_this)) + \"(:?/|$)\";\n\t      _this.regex = new RegExp(_this.pattern);\n\t      return _this;\n\t    }\n\t\n\t    _createClass(Route, [{\n\t      key: 'routes',\n\t      value: function routes(_routes2) {\n\t        var redirectRoutes = _routes2.filter(function (r) {\n\t          return r instanceof RedirectRoute;\n\t        });\n\t        var defaultRoutes = _routes2.filter(function (r) {\n\t          return r instanceof DefaultRoute;\n\t        });\n\t        var notFoundRoutes = _routes2.filter(function (r) {\n\t          return r instanceof NotFoundRoute;\n\t        });\n\t        var otherRoutes = _routes2.filter(function (r) {\n\t          return redirectRoutes.indexOf(r) === -1 && defaultRoutes.indexOf(r) === -1 && notFoundRoutes.indexOf(r) === -1;\n\t        });\n\t        if (notFoundRoutes.length > 1) error(\"Can't use more than one NotFoundRoute per route. --> \" + this.getPath());\n\t        if (defaultRoutes.length > 1) error(\"Can't use more than one DefaultRoute per route. --> \" + this.getPath());\n\t        this._routes = [].concat(redirectRoutes).concat(otherRoutes).concat(defaultRoutes).concat(notFoundRoutes);\n\t        return this;\n\t      }\n\t    }, {\n\t      key: 'matches',\n\t      value: function matches(request) {\n\t        var matcher = this.regex.exec(request.uri);\n\t        if (matcher) {\n\t          var params = {};\n\t          for (var i in this.pathParameterNames) {\n\t            if (this.pathParameterNames.hasOwnProperty(i)) {\n\t              var name = this.pathParameterNames[i];\n\t              params[name] = decodeURIComponent(matcher[parseInt(i, 10) + 1]);\n\t            }\n\t          }\n\t          return { route: this, tag: this.tag, api: this.api, found: matcher[0], params: params };\n\t        }\n\t        return false;\n\t      }\n\t    }, {\n\t      key: 'routeMatch',\n\t      value: function routeMatch(request, response, matcher) {\n\t        var matches = _get(Route.prototype.__proto__ || Object.getPrototypeOf(Route.prototype), 'routeMatch', this).call(this, request, response, matcher);\n\t        this.processRoutes(request, response, matcher);\n\t        return matches;\n\t      }\n\t    }, {\n\t      key: 'processRoutes',\n\t      value: function processRoutes(request, response, matcher) {\n\t        return _get(Route.prototype.__proto__ || Object.getPrototypeOf(Route.prototype), 'processRoutes', this).call(this, this.createRequest(request, matcher), response, this._routes);\n\t      }\n\t    }, {\n\t      key: 'getPath',\n\t      value: function getPath() {\n\t        return this.name || this.path || (typeof this.tag === 'string' ? this.tag : '');\n\t      }\n\t    }]);\n\t\n\t    return Route;\n\t  }(Handler);\n\t\n\t  var InitialRoute = function (_Route) {\n\t    _inherits(InitialRoute, _Route);\n\t\n\t    function InitialRoute() {\n\t      _classCallCheck(this, InitialRoute);\n\t\n\t      return _possibleConstructorReturn(this, (InitialRoute.__proto__ || Object.getPrototypeOf(InitialRoute)).apply(this, arguments));\n\t    }\n\t\n\t    return InitialRoute;\n\t  }(Route);\n\t\n\t  var ChildRequest = function ChildRequest(request, matcher) {\n\t    _classCallCheck(this, ChildRequest);\n\t\n\t    this.request = request;\n\t    this.matcher = matcher;\n\t    this.uri = this.request.uri.substring(matcher.found.length);\n\t    this.parentUri = this.request.uri.substring(0, matcher.found.length);\n\t    this.query = this.request.query;\n\t  };\n\t\n\t  var NotFoundRoute = function (_Handler2) {\n\t    _inherits(NotFoundRoute, _Handler2);\n\t\n\t    function NotFoundRoute(options) {\n\t      _classCallCheck(this, NotFoundRoute);\n\t\n\t      var _this3 = _possibleConstructorReturn(this, (NotFoundRoute.__proto__ || Object.getPrototypeOf(NotFoundRoute)).call(this, options));\n\t\n\t      options = options || {};\n\t      _this3.tag = options.tag;\n\t      _this3.api = options.api;\n\t      return _this3;\n\t    }\n\t\n\t    _createClass(NotFoundRoute, [{\n\t      key: 'matches',\n\t      value: function matches(request) {\n\t        return { route: this, tag: this.tag, api: this.api, found: request.uri };\n\t      }\n\t    }]);\n\t\n\t    return NotFoundRoute;\n\t  }(Handler);\n\t\n\t  var RedirectRoute = function (_Handler3) {\n\t    _inherits(RedirectRoute, _Handler3);\n\t\n\t    function RedirectRoute(options) {\n\t      _classCallCheck(this, RedirectRoute);\n\t\n\t      var _this4 = _possibleConstructorReturn(this, (RedirectRoute.__proto__ || Object.getPrototypeOf(RedirectRoute)).call(this, options));\n\t\n\t      options = options || {};\n\t      _this4.from = options.from;\n\t      _this4.to = options.to;\n\t      _this4.pattern = \"(^/?)\" + _this4.from + \"(/|$)\";\n\t      _this4.regex = new RegExp(_this4.pattern);\n\t      return _this4;\n\t    }\n\t\n\t    _createClass(RedirectRoute, [{\n\t      key: 'process',\n\t      value: function process(request, response) {\n\t        var uri = request.uri.replace(this.regex, \"$1\" + this.to + \"$2\");\n\t        if (uri !== request.uri) {\n\t          var parent = request.parentUri || \"\";\n\t          response.redirectTo = parent + uri;\n\t          return true;\n\t        }\n\t      }\n\t    }]);\n\t\n\t    return RedirectRoute;\n\t  }(Handler);\n\t\n\t  var DefaultRoute = function (_Handler4) {\n\t    _inherits(DefaultRoute, _Handler4);\n\t\n\t    function DefaultRoute(options) {\n\t      _classCallCheck(this, DefaultRoute);\n\t\n\t      var _this5 = _possibleConstructorReturn(this, (DefaultRoute.__proto__ || Object.getPrototypeOf(DefaultRoute)).call(this, options));\n\t\n\t      options = options || {};\n\t      _this5.tag = options.tag;\n\t      _this5.api = options.api;\n\t      return _this5;\n\t    }\n\t\n\t    _createClass(DefaultRoute, [{\n\t      key: 'matches',\n\t      value: function matches(request) {\n\t        var uri = request.uri.trim();\n\t        if (uri === \"/\" || uri === \"\") return { route: this, tag: this.tag, api: this.api, found: uri };\n\t      }\n\t    }]);\n\t\n\t    return DefaultRoute;\n\t  }(Handler);\n\t\n\t  var Request = function Request(uri, query) {\n\t    _classCallCheck(this, Request);\n\t\n\t    this.uri = uri;\n\t    this.query = query;\n\t  };\n\t\n\t  var Response = function () {\n\t    function Response(request) {\n\t      _classCallCheck(this, Response);\n\t\n\t      this.uri = request.uri;\n\t      this.matches = [];\n\t      this.params = {};\n\t      this.query = request.query;\n\t    }\n\t\n\t    _createClass(Response, [{\n\t      key: 'add',\n\t      value: function add(matcher) {\n\t        this.matches.push(matcher);\n\t        var params = matcher.params;\n\t        if (params) {\n\t          for (var key in params) {\n\t            if (params.hasOwnProperty(key)) {\n\t              this.params[key] = params[key];\n\t            }\n\t          }\n\t        }\n\t      }\n\t    }, {\n\t      key: 'get',\n\t      value: function get(index) {\n\t        return this.matches[index];\n\t      }\n\t    }, {\n\t      key: 'size',\n\t      value: function size() {\n\t        return this.matches.length;\n\t      }\n\t    }, {\n\t      key: 'isEmpty',\n\t      value: function isEmpty() {\n\t        return this.matches.length;\n\t      }\n\t    }]);\n\t\n\t    return Response;\n\t  }();\n\t\n\t  riot.tag('route', '<router-content></router-content>', function (opts) {\n\t    this.calculateLevel = function (target) {\n\t      var level = 0;\n\t      if (target.parent) level += this.calculateLevel(target.parent);\n\t      if (target.opts.__router_level) level += target.opts.__router_level;\n\t      if (target.__router_tag) level += 1;\n\t      return level;\n\t    }.bind(this);\n\t\n\t    this.normalizeTag = function (tag, api, options) {\n\t      var result = tag(api, options);\n\t      if (typeof result === 'string') {\n\t        tag = result;\n\t      } else {\n\t        tag = result.tag || tag;\n\t        api = result.api || api;\n\t      }\n\t      return [tag, api, options];\n\t    };\n\t\n\t    this.unmountTag = function () {\n\t      if (this.instance) this.instance.unmount(true);\n\t    };\n\t\n\t    this.mountTag = function (tag, api, options) {\n\t      if (typeof tag === 'function') {\n\t        var _normalizeTag = this.normalizeTag(tag, api, options);\n\t\n\t        var _normalizeTag2 = _slicedToArray(_normalizeTag, 3);\n\t\n\t        tag = _normalizeTag2[0];\n\t        api = _normalizeTag2[1];\n\t        options = _normalizeTag2[2];\n\t      }\n\t      if (this.canUpdate(tag, api, options)) {\n\t        this.instance.update(api);\n\t      } else {\n\t        this.unmountTag();\n\t        if (tag) {\n\t          this.root.replaceChild(document.createElement(tag), this.root.children[0]);\n\t          this.instance = riot.mount(this.root.children[0], tag, api)[0];\n\t          this.instanceTag = tag;\n\t          this.instanceApi = api;\n\t        }\n\t      }\n\t    };\n\t\n\t    this.canUpdate = function (tag, api, options) {\n\t      if (!router.config.updatable && !opts.updatable && !options.updatable || !this.instance || !this.instance.isMounted || this.instanceTag !== tag) return false;\n\t      return true;\n\t    };\n\t\n\t    this.updateRoute = function () {\n\t      var mount = { tag: null };\n\t      if (router && router.current) {\n\t        var response = router.current;\n\t        if (this.level <= response.size()) {\n\t          var matcher = response.get(this.level);\n\t          if (matcher) {\n\t            var params = matcher.params || {};\n\t            var query = response.query || {};\n\t            var api = extend(true, {}, opts, query, matcher.api, params, { __router_level: this.level, query: query });\n\t            mount = { tag: matcher.tag, api: api, updatable: matcher.route.updatable };\n\t          }\n\t        }\n\t      }\n\t      if (mount.tag) this.mountTag(mount.tag, mount.api, mount);else this.unmountTag();\n\t    }.bind(this);\n\t\n\t    this.__router_tag = 'route';\n\t    this.level = this.calculateLevel(this);\n\t    router.on('route:updated', this.updateRoute);\n\t    this.on('unmount', function () {\n\t      router.off('route:updated', this.updateRoute);\n\t      this.unmountTag();\n\t    }.bind(this));\n\t    this.on('mount', function () {\n\t      this.updateRoute();\n\t    }.bind(this));\n\t  });\n\t\n\t  var router = new Router();\n\t  router.Route = Route;\n\t  router.DefaultRoute = DefaultRoute;\n\t  router.RedirectRoute = RedirectRoute;\n\t  router.NotFoundRoute = NotFoundRoute;\n\t  router._ = { Response: Response, Request: Request };\n\t\n\t  router.config = {\n\t    updatable: false\n\t  };\n\t\n\t  module.exports = router;\n\t});\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = riot;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\t\n\tvar observable = _interopDefault(__webpack_require__(3));\n\t\n\t/**\n\t * Simple client-side router\n\t * @module riot-route\n\t */\n\t\n\tvar RE_ORIGIN = /^.+?\\/\\/+[^\\/]+/;\n\tvar EVENT_LISTENER = 'EventListener';\n\tvar REMOVE_EVENT_LISTENER = 'remove' + EVENT_LISTENER;\n\tvar ADD_EVENT_LISTENER = 'add' + EVENT_LISTENER;\n\tvar HAS_ATTRIBUTE = 'hasAttribute';\n\tvar POPSTATE = 'popstate';\n\tvar HASHCHANGE = 'hashchange';\n\tvar TRIGGER = 'trigger';\n\tvar MAX_EMIT_STACK_LEVEL = 3;\n\tvar win = typeof window != 'undefined' && window;\n\tvar doc = typeof document != 'undefined' && document;\n\tvar hist = win && history;\n\tvar loc = win && (hist.location || win.location);\n\tvar prot = Router.prototype;\n\tvar clickEvent = doc && doc.ontouchstart ? 'touchstart' : 'click';\n\tvar central = observable();\n\t\n\tvar started = false;\n\tvar routeFound = false;\n\tvar debouncedEmit;\n\tvar base;\n\tvar current;\n\tvar parser;\n\tvar secondParser;\n\tvar emitStack = [];\n\tvar emitStackLevel = 0;\n\t\n\t/**\n\t * Default parser. You can replace it via router.parser method.\n\t * @param {string} path - current path (normalized)\n\t * @returns {array} array\n\t */\n\tfunction DEFAULT_PARSER(path) {\n\t  return path.split(/[/?#]/)\n\t}\n\t\n\t/**\n\t * Default parser (second). You can replace it via router.parser method.\n\t * @param {string} path - current path (normalized)\n\t * @param {string} filter - filter string (normalized)\n\t * @returns {array} array\n\t */\n\tfunction DEFAULT_SECOND_PARSER(path, filter) {\n\t  var f = filter\n\t    .replace(/\\?/g, '\\\\?')\n\t    .replace(/\\*/g, '([^/?#]+?)')\n\t    .replace(/\\.\\./, '.*');\n\t  var re = new RegExp((\"^\" + f + \"$\"));\n\t  var args = path.match(re);\n\t\n\t  if (args) { return args.slice(1) }\n\t}\n\t\n\t/**\n\t * Simple/cheap debounce implementation\n\t * @param   {function} fn - callback\n\t * @param   {number} delay - delay in seconds\n\t * @returns {function} debounced function\n\t */\n\tfunction debounce(fn, delay) {\n\t  var t;\n\t  return function () {\n\t    clearTimeout(t);\n\t    t = setTimeout(fn, delay);\n\t  }\n\t}\n\t\n\t/**\n\t * Set the window listeners to trigger the routes\n\t * @param {boolean} autoExec - see route.start\n\t */\n\tfunction start(autoExec) {\n\t  debouncedEmit = debounce(emit, 1);\n\t  win[ADD_EVENT_LISTENER](POPSTATE, debouncedEmit);\n\t  win[ADD_EVENT_LISTENER](HASHCHANGE, debouncedEmit);\n\t  doc[ADD_EVENT_LISTENER](clickEvent, click);\n\t  if (autoExec) { emit(true); }\n\t}\n\t\n\t/**\n\t * Router class\n\t */\n\tfunction Router() {\n\t  this.$ = [];\n\t  observable(this); // make it observable\n\t  central.on('stop', this.s.bind(this));\n\t  central.on('emit', this.e.bind(this));\n\t}\n\t\n\tfunction normalize(path) {\n\t  return path.replace(/^\\/|\\/$/, '')\n\t}\n\t\n\tfunction isString(str) {\n\t  return typeof str == 'string'\n\t}\n\t\n\t/**\n\t * Get the part after domain name\n\t * @param {string} href - fullpath\n\t * @returns {string} path from root\n\t */\n\tfunction getPathFromRoot(href) {\n\t  return (href || loc.href).replace(RE_ORIGIN, '')\n\t}\n\t\n\t/**\n\t * Get the part after base\n\t * @param {string} href - fullpath\n\t * @returns {string} path from base\n\t */\n\tfunction getPathFromBase(href) {\n\t  return base[0] === '#'\n\t    ? (href || loc.href || '').split(base)[1] || ''\n\t    : (loc ? getPathFromRoot(href) : href || '').replace(base, '')\n\t}\n\t\n\tfunction emit(force) {\n\t  // the stack is needed for redirections\n\t  var isRoot = emitStackLevel === 0;\n\t  if (MAX_EMIT_STACK_LEVEL <= emitStackLevel) { return }\n\t\n\t  emitStackLevel++;\n\t  emitStack.push(function() {\n\t    var path = getPathFromBase();\n\t    if (force || path !== current) {\n\t      central[TRIGGER]('emit', path);\n\t      current = path;\n\t    }\n\t  });\n\t  if (isRoot) {\n\t    var first;\n\t    while (first = emitStack.shift()) { first(); } // stack increses within this call\n\t    emitStackLevel = 0;\n\t  }\n\t}\n\t\n\tfunction click(e) {\n\t  if (\n\t    e.which !== 1 // not left click\n\t    || e.metaKey || e.ctrlKey || e.shiftKey // or meta keys\n\t    || e.defaultPrevented // or default prevented\n\t  ) { return }\n\t\n\t  var el = e.target;\n\t  while (el && el.nodeName !== 'A') { el = el.parentNode; }\n\t\n\t  if (\n\t    !el || el.nodeName !== 'A' // not A tag\n\t    || el[HAS_ATTRIBUTE]('download') // has download attr\n\t    || !el[HAS_ATTRIBUTE]('href') // has no href attr\n\t    || el.target && el.target !== '_self' // another window or frame\n\t    || el.href.indexOf(loc.href.match(RE_ORIGIN)[0]) === -1 // cross origin\n\t  ) { return }\n\t\n\t  if (el.href !== loc.href\n\t    && (\n\t      el.href.split('#')[0] === loc.href.split('#')[0] // internal jump\n\t      || base[0] !== '#' && getPathFromRoot(el.href).indexOf(base) !== 0 // outside of base\n\t      || base[0] === '#' && el.href.split(base)[0] !== loc.href.split(base)[0] // outside of #base\n\t      || !go(getPathFromBase(el.href), el.title || doc.title) // route not found\n\t    )) { return }\n\t\n\t  e.preventDefault();\n\t}\n\t\n\t/**\n\t * Go to the path\n\t * @param {string} path - destination path\n\t * @param {string} title - page title\n\t * @param {boolean} shouldReplace - use replaceState or pushState\n\t * @returns {boolean} - route not found flag\n\t */\n\tfunction go(path, title, shouldReplace) {\n\t  // Server-side usage: directly execute handlers for the path\n\t  if (!hist) { return central[TRIGGER]('emit', getPathFromBase(path)) }\n\t\n\t  path = base + normalize(path);\n\t  title = title || doc.title;\n\t  // browsers ignores the second parameter `title`\n\t  shouldReplace\n\t    ? hist.replaceState(null, title, path)\n\t    : hist.pushState(null, title, path);\n\t  // so we need to set it manually\n\t  doc.title = title;\n\t  routeFound = false;\n\t  emit();\n\t  return routeFound\n\t}\n\t\n\t/**\n\t * Go to path or set action\n\t * a single string:                go there\n\t * two strings:                    go there with setting a title\n\t * two strings and boolean:        replace history with setting a title\n\t * a single function:              set an action on the default route\n\t * a string/RegExp and a function: set an action on the route\n\t * @param {(string|function)} first - path / action / filter\n\t * @param {(string|RegExp|function)} second - title / action\n\t * @param {boolean} third - replace flag\n\t */\n\tprot.m = function(first, second, third) {\n\t  if (isString(first) && (!second || isString(second))) { go(first, second, third || false); }\n\t  else if (second) { this.r(first, second); }\n\t  else { this.r('@', first); }\n\t};\n\t\n\t/**\n\t * Stop routing\n\t */\n\tprot.s = function() {\n\t  this.off('*');\n\t  this.$ = [];\n\t};\n\t\n\t/**\n\t * Emit\n\t * @param {string} path - path\n\t */\n\tprot.e = function(path) {\n\t  this.$.concat('@').some(function(filter) {\n\t    var args = (filter === '@' ? parser : secondParser)(normalize(path), normalize(filter));\n\t    if (typeof args != 'undefined') {\n\t      this[TRIGGER].apply(null, [filter].concat(args));\n\t      return routeFound = true // exit from loop\n\t    }\n\t  }, this);\n\t};\n\t\n\t/**\n\t * Register route\n\t * @param {string} filter - filter for matching to url\n\t * @param {function} action - action to register\n\t */\n\tprot.r = function(filter, action) {\n\t  if (filter !== '@') {\n\t    filter = '/' + normalize(filter);\n\t    this.$.push(filter);\n\t  }\n\t  this.on(filter, action);\n\t};\n\t\n\tvar mainRouter = new Router();\n\tvar route = mainRouter.m.bind(mainRouter);\n\t\n\t/**\n\t * Create a sub router\n\t * @returns {function} the method of a new Router object\n\t */\n\troute.create = function() {\n\t  var newSubRouter = new Router();\n\t  // assign sub-router's main method\n\t  var router = newSubRouter.m.bind(newSubRouter);\n\t  // stop only this sub-router\n\t  router.stop = newSubRouter.s.bind(newSubRouter);\n\t  return router\n\t};\n\t\n\t/**\n\t * Set the base of url\n\t * @param {(str|RegExp)} arg - a new base or '#' or '#!'\n\t */\n\troute.base = function(arg) {\n\t  base = arg || '#';\n\t  current = getPathFromBase(); // recalculate current path\n\t};\n\t\n\t/** Exec routing right now **/\n\troute.exec = function() {\n\t  emit(true);\n\t};\n\t\n\t/**\n\t * Replace the default router to yours\n\t * @param {function} fn - your parser function\n\t * @param {function} fn2 - your secondParser function\n\t */\n\troute.parser = function(fn, fn2) {\n\t  if (!fn && !fn2) {\n\t    // reset parser for testing...\n\t    parser = DEFAULT_PARSER;\n\t    secondParser = DEFAULT_SECOND_PARSER;\n\t  }\n\t  if (fn) { parser = fn; }\n\t  if (fn2) { secondParser = fn2; }\n\t};\n\t\n\t/**\n\t * Helper function to get url query as an object\n\t * @returns {object} parsed query\n\t */\n\troute.query = function() {\n\t  var q = {};\n\t  var href = loc.href || current;\n\t  href.replace(/[?&](.+?)=([^&]*)/g, function(_, k, v) { q[k] = v; });\n\t  return q\n\t};\n\t\n\t/** Stop routing **/\n\troute.stop = function () {\n\t  if (started) {\n\t    if (win) {\n\t      win[REMOVE_EVENT_LISTENER](POPSTATE, debouncedEmit);\n\t      win[REMOVE_EVENT_LISTENER](HASHCHANGE, debouncedEmit);\n\t      doc[REMOVE_EVENT_LISTENER](clickEvent, click);\n\t    }\n\t    central[TRIGGER]('stop');\n\t    started = false;\n\t  }\n\t};\n\t\n\t/**\n\t * Start routing\n\t * @param {boolean} autoExec - automatically exec after starting if true\n\t */\n\troute.start = function (autoExec) {\n\t  if (!started) {\n\t    if (win) {\n\t      if (document.readyState === 'complete') { start(autoExec); }\n\t      // the timeout is needed to solve\n\t      // a weird safari bug https://github.com/riot/route/issues/33\n\t      else { win[ADD_EVENT_LISTENER]('load', function() {\n\t        setTimeout(function() { start(autoExec); }, 1);\n\t      }); }\n\t    }\n\t    started = true;\n\t  }\n\t};\n\t\n\t/** Prepare the router **/\n\troute.base();\n\troute.parser();\n\t\n\tmodule.exports = route;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t;(function(window, undefined) {var observable = function(el) {\n\t\n\t  /**\n\t   * Extend the original object or create a new empty one\n\t   * @type { Object }\n\t   */\n\t\n\t  el = el || {}\n\t\n\t  /**\n\t   * Private variables\n\t   */\n\t  var callbacks = {},\n\t    slice = Array.prototype.slice\n\t\n\t  /**\n\t   * Public Api\n\t   */\n\t\n\t  // extend the el object adding the observable methods\n\t  Object.defineProperties(el, {\n\t    /**\n\t     * Listen to the given `event` ands\n\t     * execute the `callback` each time an event is triggered.\n\t     * @param  { String } event - event id\n\t     * @param  { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    on: {\n\t      value: function(event, fn) {\n\t        if (typeof fn == 'function')\n\t          (callbacks[event] = callbacks[event] || []).push(fn)\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Removes the given `event` listeners\n\t     * @param   { String } event - event id\n\t     * @param   { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    off: {\n\t      value: function(event, fn) {\n\t        if (event == '*' && !fn) callbacks = {}\n\t        else {\n\t          if (fn) {\n\t            var arr = callbacks[event]\n\t            for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n\t              if (cb == fn) arr.splice(i--, 1)\n\t            }\n\t          } else delete callbacks[event]\n\t        }\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Listen to the given `event` and\n\t     * execute the `callback` at most once\n\t     * @param   { String } event - event id\n\t     * @param   { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    one: {\n\t      value: function(event, fn) {\n\t        function on() {\n\t          el.off(event, on)\n\t          fn.apply(el, arguments)\n\t        }\n\t        return el.on(event, on)\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Execute all callback functions that listen to\n\t     * the given `event`\n\t     * @param   { String } event - event id\n\t     * @returns { Object } el\n\t     */\n\t    trigger: {\n\t      value: function(event) {\n\t\n\t        // getting the arguments\n\t        var arglen = arguments.length - 1,\n\t          args = new Array(arglen),\n\t          fns,\n\t          fn,\n\t          i\n\t\n\t        for (i = 0; i < arglen; i++) {\n\t          args[i] = arguments[i + 1] // skip first argument\n\t        }\n\t\n\t        fns = slice.call(callbacks[event] || [], 0)\n\t\n\t        for (i = 0; fn = fns[i]; ++i) {\n\t          fn.apply(el, args)\n\t        }\n\t\n\t        if (callbacks['*'] && event != '*')\n\t          el.trigger.apply(el, ['*', event].concat(args))\n\t\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    }\n\t  })\n\t\n\t  return el\n\t\n\t}\n\t  /* istanbul ignore next */\n\t  // support CommonJS, AMD & browser\n\t  if (true)\n\t    module.exports = observable\n\t  else if (typeof define === 'function' && define.amd)\n\t    define(function() { return observable })\n\t  else\n\t    window.observable = observable\n\t\n\t})(typeof window != 'undefined' ? window : undefined);\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar hasOwn = Object.prototype.hasOwnProperty;\n\tvar toStr = Object.prototype.toString;\n\t\n\tvar isArray = function isArray(arr) {\n\t\tif (typeof Array.isArray === 'function') {\n\t\t\treturn Array.isArray(arr);\n\t\t}\n\t\n\t\treturn toStr.call(arr) === '[object Array]';\n\t};\n\t\n\tvar isPlainObject = function isPlainObject(obj) {\n\t\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\t\treturn false;\n\t\t}\n\t\n\t\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\t\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t\t// Not own constructor property must be Object\n\t\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\t// Own properties are enumerated firstly, so to speed up,\n\t\t// if last one is own, then all properties are own.\n\t\tvar key;\n\t\tfor (key in obj) {/**/}\n\t\n\t\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n\t};\n\t\n\tmodule.exports = function extend() {\n\t\tvar options, name, src, copy, copyIsArray, clone,\n\t\t\ttarget = arguments[0],\n\t\t\ti = 1,\n\t\t\tlength = arguments.length,\n\t\t\tdeep = false;\n\t\n\t\t// Handle a deep copy situation\n\t\tif (typeof target === 'boolean') {\n\t\t\tdeep = target;\n\t\t\ttarget = arguments[1] || {};\n\t\t\t// skip the boolean and the target\n\t\t\ti = 2;\n\t\t} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {\n\t\t\ttarget = {};\n\t\t}\n\t\n\t\tfor (; i < length; ++i) {\n\t\t\toptions = arguments[i];\n\t\t\t// Only deal with non-null/undefined values\n\t\t\tif (options != null) {\n\t\t\t\t// Extend the base object\n\t\t\t\tfor (name in options) {\n\t\t\t\t\tsrc = target[name];\n\t\t\t\t\tcopy = options[name];\n\t\n\t\t\t\t\t// Prevent never-ending loop\n\t\t\t\t\tif (target !== copy) {\n\t\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\t\ttarget[name] = extend(deep, clone, copy);\n\t\n\t\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Return the modified object\n\t\treturn target;\n\t};\n\t\n\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// router.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e4100e79d53440384f82","var riot = require('riot');\nvar riotroute = require('riot-route');\nvar extend = require('extend');\nvar error = console && console.error || function() {};\n\nfunction customRiotParser(path) {\n  var raw = path.split('?'),\n      uri = raw[0].split('/'),\n      query = raw[1],\n      params = {}\n  if (query) {\n    query.split('&').forEach(function(v) {\n      var c = v.split('=')\n      params[c[0]] = c[1]\n    })\n  }\n  uri.push(params)\n  return uri\n}\n\nclass Router {\n\n  constructor() {\n    riot.observable(this);\n    this.interceptors = [this.processRoute.bind(this)];\n    this.handler = new InitialRoute();\n    this.current = new Context(\"\").response;\n    this.process = this.process.bind(this);\n  }\n\n  route(handler) {\n    this.handler = handler;\n  }\n\n  routes(routes) {\n    this.route(new InitialRoute().routes(routes));\n  }\n\n  use(interceptor) {\n    this.interceptors.push(interceptor);\n  }\n\n  process() {\n    var params = Array.prototype.slice.call(arguments);\n    var query = {};\n    var uri = params.filter(function(p) {\n      if (typeof(p) !== 'string') {\n        query = p;\n        return false;\n      }\n      return true;\n    }).join(\"/\");\n    if (uri[0] !== '/') uri = \"/\" + uri; // handle '#any' as '#/any'\n    var context = new Context(new Request(uri, query));\n    if (!this.rootContext) this.rootContext = context;\n    this.processRequest(context);\n    return context;\n  }\n\n  processRequest(context) {\n    this.processInterceptors(context);\n    return this.processResponse(context);\n  }\n\n  processResponse(context) {\n    if (this.isRedirect(context)) {\n      return this.processRedirect(context);\n    }\n    var {request, response} = context;\n    if (!response.redirectTo) {\n      this.current = response;\n      this.rootContext = null;\n      this.trigger('route:updated', response);\n      return context;\n    }\n  }\n\n  isRedirect(context) {\n    return !!context.response.redirectTo;\n  }\n\n  processRedirect(context) {\n    var uri = context.response.redirectTo;\n    this.rootContext.addRedirect(uri);\n    this.navigateTo(uri);\n  }\n\n  navigateTo() {\n    var args = Array.prototype.slice.call(arguments);\n    if(typeof(args[1]) === 'boolean') {\n      args.splice(1, 0, '');\n    }\n    riotroute.apply(null, args);\n  }\n\n  processInterceptors(context, preInterceptors, postInterceptors) {\n    var interceptors = (preInterceptors || []).concat(this.interceptors).concat(postInterceptors || []);\n    var next = function next() {\n      if (!context.stop) {\n        var processor = interceptors.shift();\n        var {request, response} = context;\n        if (processor) {\n          return processor(request, response, next, context);\n        }\n      }\n      return context;\n    };\n    return next();\n  }\n\n  processRoute(request, response, next, context) {\n    this.handler.process(request, response, context);\n    return next();\n  }\n\n  start() {\n    riotroute.parser(customRiotParser);\n    riotroute(this.process);\n    riotroute.start();\n    this.exec();\n  }\n\n  exec() {\n    riotroute.exec(this.process);    \n  }\n\n}\n\nclass Context {\n  constructor(request) {\n    this.request = typeof(request) === 'string' ? new Request(request) : request;\n    this.response = new Response(this.request);\n    this.redirectStack = [];\n  }\n\n  addRedirect(uri) {\n    if (this.redirectStack.indexOf(uri) > -1)\n      throw new Error(\"Cyclic redirection to \" + uri + \". Stack = \" + this.redirectStack);\n    this.redirectStack.push(uri);\n  }\n\n}\n\nclass Handler {\n  constructor() {\n  }\n\n  matches(request) {\n    return false;\n  }\n\n  process(request, response) {\n    var matcher = this.matches(request);\n    if (!matcher) return this.routeMiss(request, response);\n    return this.routeMatch(request, response, matcher);\n  }\n\n  routeMatch(request, response, matcher) {\n    response.add(matcher);\n    return true;\n  }\n\n  routeMiss(request, response) {\n    return false;\n  }\n\n  processRoutes(request, response, routes) {\n    if (routes && routes.length) {\n      var t = routes.length;\n      for(var i = 0; i < t; i++) {\n        var route = routes[i];\n        if (route.process(request, response))\n          return true;\n      }\n      return false;\n    }\n  }\n\n  createRequest(request, matcher) {\n    return new ChildRequest(request, matcher);\n  }\n}\n\nclass Route extends Handler {\n  constructor(options) {\n    super(options);\n    options = options || {};\n    this.tag = options.tag;\n    this.api = options.api;\n    this.path = options.path;\n    this.name = options.name;\n    this.updatable = options.updatable;\n    this.pathParameterNames = [];\n    var path = this.getPath().replace(/^\\//,\"\");\n    this.pattern = \"^/?\" + path.replace(/:([^/]+)/g, function(ignored, group) {\n      this.pathParameterNames.push(group);\n      return \"([^/]+)\";\n    }.bind(this)) + \"(:?/|$)\";\n    this.regex = new RegExp(this.pattern);\n  }\n\n  routes(routes) {\n    var redirectRoutes = routes.filter(function(r) { return r instanceof RedirectRoute; });\n    var defaultRoutes = routes.filter(function(r) { return r instanceof DefaultRoute; });\n    var notFoundRoutes = routes.filter(function(r) { return r instanceof NotFoundRoute; });\n    var otherRoutes = routes.filter(function(r) { return redirectRoutes.indexOf(r) === -1\n                                                      &&  defaultRoutes.indexOf(r) === -1\n                                                      && notFoundRoutes.indexOf(r) === -1; });\n    if (notFoundRoutes.length > 1) error(\"Can't use more than one NotFoundRoute per route. --> \" + this.getPath());\n    if (defaultRoutes.length > 1) error(\"Can't use more than one DefaultRoute per route. --> \" + this.getPath());\n    this._routes = [].concat(redirectRoutes).concat(otherRoutes).concat(defaultRoutes).concat(notFoundRoutes);\n    return this;\n  }\n\n  matches(request) {\n    var matcher = this.regex.exec(request.uri);\n    if (matcher) {\n      var params = {};\n      for (var i in this.pathParameterNames) {\n        if (this.pathParameterNames.hasOwnProperty(i)) {\n          var name = this.pathParameterNames[i];\n          params[name] = decodeURIComponent(matcher[parseInt(i, 10) + 1]);\n        }\n      }\n      return {route: this, tag: this.tag, api: this.api, found: matcher[0], params: params};\n    }\n    return false;\n  }\n\n  routeMatch(request, response, matcher) {\n    var matches = super.routeMatch(request, response, matcher);\n    this.processRoutes(request, response, matcher);\n    return matches;\n  }\n\n  processRoutes(request, response, matcher) {\n    return super.processRoutes(this.createRequest(request, matcher), response, this._routes);\n  }\n\n  getPath() {\n    return this.name || this.path || (typeof this.tag === 'string' ? this.tag : '');\n  }\n}\n\nclass InitialRoute extends Route {\n\n}\n\nclass ChildRequest {\n  constructor(request, matcher) {\n    this.request = request;\n    this.matcher = matcher;\n    this.uri = this.request.uri.substring(matcher.found.length);\n    this.parentUri = this.request.uri.substring(0, matcher.found.length);\n    this.query = this.request.query;\n  }\n}\n\nclass NotFoundRoute extends Handler {\n  constructor(options) {\n    super(options);\n    options = options || {};\n    this.tag = options.tag;\n    this.api = options.api;\n  }\n  matches(request) {\n    return {route: this, tag: this.tag, api: this.api, found: request.uri};\n  }\n}\n\nclass RedirectRoute extends Handler {\n  constructor(options) {\n    super(options);\n    options = options || {};\n    this.from = options.from;\n    this.to = options.to;\n    this.pattern = \"(^/?)\" + this.from + \"(/|$)\";\n    this.regex = new RegExp(this.pattern);\n  }\n\n  process(request, response) {\n    var uri = request.uri.replace(this.regex, \"$1\" + this.to + \"$2\");\n    if (uri !== request.uri) {\n      var parent = request.parentUri || \"\";\n      response.redirectTo = parent + uri;\n      return true;\n    }\n  }\n\n}\n\nclass DefaultRoute extends Handler {\n  constructor(options) {\n    super(options);\n    options = options || {};\n    this.tag = options.tag;\n    this.api = options.api;\n  }\n  matches(request) {\n    var uri = request.uri.trim();\n    if (uri === \"/\" || uri === \"\")\n      return {route: this, tag: this.tag, api: this.api, found: uri};\n  }\n}\n\nclass Request {\n  constructor(uri, query) {\n    this.uri = uri;\n    this.query = query;\n  }\n}\n\nclass Response {\n  constructor(request) {\n    this.uri = request.uri;\n    this.matches = [];\n    this.params = {};\n    this.query = request.query;\n  }\n  add(matcher) {\n    this.matches.push(matcher);\n    var params = matcher.params;\n    if (params) {\n      for (var key in params) {\n        if (params.hasOwnProperty(key)) {\n          this.params[key] = params[key];\n        }\n      }\n    }\n  }\n\n  get(index) {\n    return this.matches[index];\n  }\n\n  size() {\n    return this.matches.length;\n  }\n\n  isEmpty() {\n    return this.matches.length;\n  }\n\n}\n\nriot.tag('route', '<router-content></router-content>', function(opts) {\n  this.calculateLevel = function(target) {\n    var level = 0;\n    if (target.parent) level += this.calculateLevel(target.parent);\n    if (target.opts.__router_level) level += target.opts.__router_level;\n    if (target.__router_tag) level += 1;\n    return level;\n  }.bind(this);\n\n  this.normalizeTag = function(tag, api, options) {\n    var result = tag(api, options);\n    if (typeof result === 'string') {\n      tag = result;\n    } else  {\n      tag = result.tag || tag;\n      api = result.api || api;\n    }\n    return [tag, api, options];\n  }\n\n  this.unmountTag = function() {\n    if (this.instance)\n        this.instance.unmount(true);\n  }\n\n  this.mountTag = function(tag, api, options) {\n    if (typeof tag === 'function') {\n      [tag, api, options] = this.normalizeTag(tag, api, options);\n    }\n    if (this.canUpdate(tag, api, options)) {\n      this.instance.update(api);\n    } else {\n      this.unmountTag();\n      if (tag) {\n        this.root.replaceChild(document.createElement(tag), this.root.children[0]);\n        this.instance = riot.mount(this.root.children[0], tag, api)[0];\n        this.instanceTag = tag;\n        this.instanceApi = api;\n        \n      }\n    }\n  }\n\n  this.canUpdate = function(tag, api, options) {\n    if ((!router.config.updatable && !opts.updatable && !options.updatable)\n      || !this.instance\n      || !this.instance.isMounted\n      || this.instanceTag !== tag)\n      return false;\n    return true;\n  }\n\n  this.updateRoute = function() {\n    var mount = {tag: null};\n    if (router && router.current) {\n      var response = router.current;\n      if (this.level <= response.size()) {\n        var matcher = response.get(this.level);\n        if (matcher) {\n          var params = matcher.params || {};\n          var query = response.query || {};\n          var api = extend(true, {}, opts, query, matcher.api, params, {__router_level: this.level, query: query});\n          mount = {tag: matcher.tag, api: api, updatable: matcher.route.updatable};\n        }\n      }\n    }\n    if (mount.tag)\n      this.mountTag(mount.tag, mount.api, mount);\n    else\n      this.unmountTag();\n  }.bind(this);\n\n  this.__router_tag = 'route';\n  this.level = this.calculateLevel(this);\n  router.on('route:updated', this.updateRoute);\n  this.on('unmount', function() {\n    router.off('route:updated', this.updateRoute);\n    this.unmountTag();\n  }.bind(this));\n  this.on('mount', function() {\n    this.updateRoute();\n  }.bind(this));\n});\n\nvar router = new Router();\nrouter.Route = Route;\nrouter.DefaultRoute = DefaultRoute;\nrouter.RedirectRoute = RedirectRoute;\nrouter.NotFoundRoute = NotFoundRoute;\nrouter._ = {Response: Response, Request: Request};\n\nrouter.config = {\n  updatable: false\n}\n\nmodule.exports = router;\n\n\n\n// WEBPACK FOOTER //\n// ./router.js","module.exports = riot;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"riot\"\n// module id = 1\n// module chunks = 0","'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar observable = _interopDefault(require('riot-observable'));\n\n/**\n * Simple client-side router\n * @module riot-route\n */\n\nvar RE_ORIGIN = /^.+?\\/\\/+[^\\/]+/;\nvar EVENT_LISTENER = 'EventListener';\nvar REMOVE_EVENT_LISTENER = 'remove' + EVENT_LISTENER;\nvar ADD_EVENT_LISTENER = 'add' + EVENT_LISTENER;\nvar HAS_ATTRIBUTE = 'hasAttribute';\nvar POPSTATE = 'popstate';\nvar HASHCHANGE = 'hashchange';\nvar TRIGGER = 'trigger';\nvar MAX_EMIT_STACK_LEVEL = 3;\nvar win = typeof window != 'undefined' && window;\nvar doc = typeof document != 'undefined' && document;\nvar hist = win && history;\nvar loc = win && (hist.location || win.location);\nvar prot = Router.prototype;\nvar clickEvent = doc && doc.ontouchstart ? 'touchstart' : 'click';\nvar central = observable();\n\nvar started = false;\nvar routeFound = false;\nvar debouncedEmit;\nvar base;\nvar current;\nvar parser;\nvar secondParser;\nvar emitStack = [];\nvar emitStackLevel = 0;\n\n/**\n * Default parser. You can replace it via router.parser method.\n * @param {string} path - current path (normalized)\n * @returns {array} array\n */\nfunction DEFAULT_PARSER(path) {\n  return path.split(/[/?#]/)\n}\n\n/**\n * Default parser (second). You can replace it via router.parser method.\n * @param {string} path - current path (normalized)\n * @param {string} filter - filter string (normalized)\n * @returns {array} array\n */\nfunction DEFAULT_SECOND_PARSER(path, filter) {\n  var f = filter\n    .replace(/\\?/g, '\\\\?')\n    .replace(/\\*/g, '([^/?#]+?)')\n    .replace(/\\.\\./, '.*');\n  var re = new RegExp((\"^\" + f + \"$\"));\n  var args = path.match(re);\n\n  if (args) { return args.slice(1) }\n}\n\n/**\n * Simple/cheap debounce implementation\n * @param   {function} fn - callback\n * @param   {number} delay - delay in seconds\n * @returns {function} debounced function\n */\nfunction debounce(fn, delay) {\n  var t;\n  return function () {\n    clearTimeout(t);\n    t = setTimeout(fn, delay);\n  }\n}\n\n/**\n * Set the window listeners to trigger the routes\n * @param {boolean} autoExec - see route.start\n */\nfunction start(autoExec) {\n  debouncedEmit = debounce(emit, 1);\n  win[ADD_EVENT_LISTENER](POPSTATE, debouncedEmit);\n  win[ADD_EVENT_LISTENER](HASHCHANGE, debouncedEmit);\n  doc[ADD_EVENT_LISTENER](clickEvent, click);\n  if (autoExec) { emit(true); }\n}\n\n/**\n * Router class\n */\nfunction Router() {\n  this.$ = [];\n  observable(this); // make it observable\n  central.on('stop', this.s.bind(this));\n  central.on('emit', this.e.bind(this));\n}\n\nfunction normalize(path) {\n  return path.replace(/^\\/|\\/$/, '')\n}\n\nfunction isString(str) {\n  return typeof str == 'string'\n}\n\n/**\n * Get the part after domain name\n * @param {string} href - fullpath\n * @returns {string} path from root\n */\nfunction getPathFromRoot(href) {\n  return (href || loc.href).replace(RE_ORIGIN, '')\n}\n\n/**\n * Get the part after base\n * @param {string} href - fullpath\n * @returns {string} path from base\n */\nfunction getPathFromBase(href) {\n  return base[0] === '#'\n    ? (href || loc.href || '').split(base)[1] || ''\n    : (loc ? getPathFromRoot(href) : href || '').replace(base, '')\n}\n\nfunction emit(force) {\n  // the stack is needed for redirections\n  var isRoot = emitStackLevel === 0;\n  if (MAX_EMIT_STACK_LEVEL <= emitStackLevel) { return }\n\n  emitStackLevel++;\n  emitStack.push(function() {\n    var path = getPathFromBase();\n    if (force || path !== current) {\n      central[TRIGGER]('emit', path);\n      current = path;\n    }\n  });\n  if (isRoot) {\n    var first;\n    while (first = emitStack.shift()) { first(); } // stack increses within this call\n    emitStackLevel = 0;\n  }\n}\n\nfunction click(e) {\n  if (\n    e.which !== 1 // not left click\n    || e.metaKey || e.ctrlKey || e.shiftKey // or meta keys\n    || e.defaultPrevented // or default prevented\n  ) { return }\n\n  var el = e.target;\n  while (el && el.nodeName !== 'A') { el = el.parentNode; }\n\n  if (\n    !el || el.nodeName !== 'A' // not A tag\n    || el[HAS_ATTRIBUTE]('download') // has download attr\n    || !el[HAS_ATTRIBUTE]('href') // has no href attr\n    || el.target && el.target !== '_self' // another window or frame\n    || el.href.indexOf(loc.href.match(RE_ORIGIN)[0]) === -1 // cross origin\n  ) { return }\n\n  if (el.href !== loc.href\n    && (\n      el.href.split('#')[0] === loc.href.split('#')[0] // internal jump\n      || base[0] !== '#' && getPathFromRoot(el.href).indexOf(base) !== 0 // outside of base\n      || base[0] === '#' && el.href.split(base)[0] !== loc.href.split(base)[0] // outside of #base\n      || !go(getPathFromBase(el.href), el.title || doc.title) // route not found\n    )) { return }\n\n  e.preventDefault();\n}\n\n/**\n * Go to the path\n * @param {string} path - destination path\n * @param {string} title - page title\n * @param {boolean} shouldReplace - use replaceState or pushState\n * @returns {boolean} - route not found flag\n */\nfunction go(path, title, shouldReplace) {\n  // Server-side usage: directly execute handlers for the path\n  if (!hist) { return central[TRIGGER]('emit', getPathFromBase(path)) }\n\n  path = base + normalize(path);\n  title = title || doc.title;\n  // browsers ignores the second parameter `title`\n  shouldReplace\n    ? hist.replaceState(null, title, path)\n    : hist.pushState(null, title, path);\n  // so we need to set it manually\n  doc.title = title;\n  routeFound = false;\n  emit();\n  return routeFound\n}\n\n/**\n * Go to path or set action\n * a single string:                go there\n * two strings:                    go there with setting a title\n * two strings and boolean:        replace history with setting a title\n * a single function:              set an action on the default route\n * a string/RegExp and a function: set an action on the route\n * @param {(string|function)} first - path / action / filter\n * @param {(string|RegExp|function)} second - title / action\n * @param {boolean} third - replace flag\n */\nprot.m = function(first, second, third) {\n  if (isString(first) && (!second || isString(second))) { go(first, second, third || false); }\n  else if (second) { this.r(first, second); }\n  else { this.r('@', first); }\n};\n\n/**\n * Stop routing\n */\nprot.s = function() {\n  this.off('*');\n  this.$ = [];\n};\n\n/**\n * Emit\n * @param {string} path - path\n */\nprot.e = function(path) {\n  this.$.concat('@').some(function(filter) {\n    var args = (filter === '@' ? parser : secondParser)(normalize(path), normalize(filter));\n    if (typeof args != 'undefined') {\n      this[TRIGGER].apply(null, [filter].concat(args));\n      return routeFound = true // exit from loop\n    }\n  }, this);\n};\n\n/**\n * Register route\n * @param {string} filter - filter for matching to url\n * @param {function} action - action to register\n */\nprot.r = function(filter, action) {\n  if (filter !== '@') {\n    filter = '/' + normalize(filter);\n    this.$.push(filter);\n  }\n  this.on(filter, action);\n};\n\nvar mainRouter = new Router();\nvar route = mainRouter.m.bind(mainRouter);\n\n/**\n * Create a sub router\n * @returns {function} the method of a new Router object\n */\nroute.create = function() {\n  var newSubRouter = new Router();\n  // assign sub-router's main method\n  var router = newSubRouter.m.bind(newSubRouter);\n  // stop only this sub-router\n  router.stop = newSubRouter.s.bind(newSubRouter);\n  return router\n};\n\n/**\n * Set the base of url\n * @param {(str|RegExp)} arg - a new base or '#' or '#!'\n */\nroute.base = function(arg) {\n  base = arg || '#';\n  current = getPathFromBase(); // recalculate current path\n};\n\n/** Exec routing right now **/\nroute.exec = function() {\n  emit(true);\n};\n\n/**\n * Replace the default router to yours\n * @param {function} fn - your parser function\n * @param {function} fn2 - your secondParser function\n */\nroute.parser = function(fn, fn2) {\n  if (!fn && !fn2) {\n    // reset parser for testing...\n    parser = DEFAULT_PARSER;\n    secondParser = DEFAULT_SECOND_PARSER;\n  }\n  if (fn) { parser = fn; }\n  if (fn2) { secondParser = fn2; }\n};\n\n/**\n * Helper function to get url query as an object\n * @returns {object} parsed query\n */\nroute.query = function() {\n  var q = {};\n  var href = loc.href || current;\n  href.replace(/[?&](.+?)=([^&]*)/g, function(_, k, v) { q[k] = v; });\n  return q\n};\n\n/** Stop routing **/\nroute.stop = function () {\n  if (started) {\n    if (win) {\n      win[REMOVE_EVENT_LISTENER](POPSTATE, debouncedEmit);\n      win[REMOVE_EVENT_LISTENER](HASHCHANGE, debouncedEmit);\n      doc[REMOVE_EVENT_LISTENER](clickEvent, click);\n    }\n    central[TRIGGER]('stop');\n    started = false;\n  }\n};\n\n/**\n * Start routing\n * @param {boolean} autoExec - automatically exec after starting if true\n */\nroute.start = function (autoExec) {\n  if (!started) {\n    if (win) {\n      if (document.readyState === 'complete') { start(autoExec); }\n      // the timeout is needed to solve\n      // a weird safari bug https://github.com/riot/route/issues/33\n      else { win[ADD_EVENT_LISTENER]('load', function() {\n        setTimeout(function() { start(autoExec); }, 1);\n      }); }\n    }\n    started = true;\n  }\n};\n\n/** Prepare the router **/\nroute.base();\nroute.parser();\n\nmodule.exports = route;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/riot-route/dist/cjs.route.js\n// module id = 2\n// module chunks = 0",";(function(window, undefined) {var observable = function(el) {\n\n  /**\n   * Extend the original object or create a new empty one\n   * @type { Object }\n   */\n\n  el = el || {}\n\n  /**\n   * Private variables\n   */\n  var callbacks = {},\n    slice = Array.prototype.slice\n\n  /**\n   * Public Api\n   */\n\n  // extend the el object adding the observable methods\n  Object.defineProperties(el, {\n    /**\n     * Listen to the given `event` ands\n     * execute the `callback` each time an event is triggered.\n     * @param  { String } event - event id\n     * @param  { Function } fn - callback function\n     * @returns { Object } el\n     */\n    on: {\n      value: function(event, fn) {\n        if (typeof fn == 'function')\n          (callbacks[event] = callbacks[event] || []).push(fn)\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Removes the given `event` listeners\n     * @param   { String } event - event id\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    off: {\n      value: function(event, fn) {\n        if (event == '*' && !fn) callbacks = {}\n        else {\n          if (fn) {\n            var arr = callbacks[event]\n            for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n              if (cb == fn) arr.splice(i--, 1)\n            }\n          } else delete callbacks[event]\n        }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Listen to the given `event` and\n     * execute the `callback` at most once\n     * @param   { String } event - event id\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    one: {\n      value: function(event, fn) {\n        function on() {\n          el.off(event, on)\n          fn.apply(el, arguments)\n        }\n        return el.on(event, on)\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Execute all callback functions that listen to\n     * the given `event`\n     * @param   { String } event - event id\n     * @returns { Object } el\n     */\n    trigger: {\n      value: function(event) {\n\n        // getting the arguments\n        var arglen = arguments.length - 1,\n          args = new Array(arglen),\n          fns,\n          fn,\n          i\n\n        for (i = 0; i < arglen; i++) {\n          args[i] = arguments[i + 1] // skip first argument\n        }\n\n        fns = slice.call(callbacks[event] || [], 0)\n\n        for (i = 0; fn = fns[i]; ++i) {\n          fn.apply(el, args)\n        }\n\n        if (callbacks['*'] && event != '*')\n          el.trigger.apply(el, ['*', event].concat(args))\n\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    }\n  })\n\n  return el\n\n}\n  /* istanbul ignore next */\n  // support CommonJS, AMD & browser\n  if (typeof exports === 'object')\n    module.exports = observable\n  else if (typeof define === 'function' && define.amd)\n    define(function() { return observable })\n  else\n    window.observable = observable\n\n})(typeof window != 'undefined' ? window : undefined);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/riot-observable/dist/observable.js\n// module id = 3\n// module chunks = 0","'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) {/**/}\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[0],\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = target[name];\n\t\t\t\tcopy = options[name];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\ttarget[name] = extend(deep, clone, copy);\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/extend/index.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}